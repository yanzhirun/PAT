#*yanzhirun 练习 <p id="catalogue"> pat</p>*  

##题目列表  

-<a href="#1001">1001.害死人不偿命的(3n+1)猜想</a>  
-<a href="#1002">1002.写出这个数 (20)</a>  
-<a href="#1003">1003.我要通过！(20)</a>  
-<a href="#1004">1004.成绩排名 (20)</a>  
-<a href="#1005">1005.继续(3n+1)猜想 (25)</a>  
-<a href="#1006">1006.换个格式输出整数 (15) </a>  
-<a href="#1007">1007.素数对猜想 (20)</a>  
-<a href="#1008">1008.数组元素循环右移问题 (20)</a>  
-<a href="#1009">1009.说反话 (20)</a>  
-<a href="#1010">1010.一元多项式求导 (25)</a>  
-<a href="#1011">1011.a+b和c (15)</a>  
-<a href="#1012">1012.数字分类 (20)</a>  
-<a href="#1013">1013.数素数 (20)</a>  
-<a href="#1014">1014.福尔摩斯的约会 (20)</a>  
-<a href="#1015">1015.德才论 (25)</a>  
-<a href="#1016">1016.部分a+b (15)</a>  
-<a href="#1017">1017. a除以b (20)</a>  
-<a href="#1018">1018. 锤子剪刀布 (20)</a>  
-<a href="#1019">1019. 数字黑洞 (20)</a>  
-<a href="#1020">1020. 月饼 (25)</a>  
-<a href="#1021">1021. 个位数统计 (15)</a>  
-<a href="#1022">1022. d进制的a+b (20)</a>  
-<a href="#1023">1023. 组个最小数 (20)</a>  



---

##<p id="1001">1001. 害死人不偿命的(3n+1)猜想 (15)</p>  
对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……
我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？

输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。
输出格式：输出从n计算到1需要的步数。  
<a href="#catalogue"> back to catalogue </a>

##<p id="1002">1002. 写出这个数 (20)</p>  
读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。

输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。
输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。

---
输入输出格式; 数组初始化; 越界; 
应该有简单的写法，但是这个逻辑比较容易理解。
坚持下去，会有很大进步！  
<a href="#catalogue"> back to catalogue </a>  

##<p id="1003">1003. 我要通过！(20)</p>  
“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。
得到“答案正确”的条件是：
1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；
2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；
3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。

---
这个题目看起来不难，实际上逻辑挺复杂的，参考网上其他人的思路才算弄明白。第三条应该是递推公式，归纳出来的结论 
中间A个数 X 前面A格式 = 后面A个数
想明白了以后，写起来还是有很多小细节的
*if（...）;｛｝* 不能加分号；  
break continue 跳出的范围不一样

---
int testtest(int num, char pat[10][101])
int testtest(int num, char (*pat)[101])
数组做函数参数会退化为指针！！
char pat[10][101] 相当于  char pat[][101] 相当于 char (******pat)[101]
10 不会传进去！  
<a href="#catalogue"> back to catalogue </a>

##<p id="1004">1004. 成绩排名 (20)</p>    
读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。
输入格式：每个测试输入包含1个测试用例，格式为
  第1行：正整数n
  第2行：第1个学生的姓名 学号 成绩
  第3行：第2个学生的姓名 学号 成绩
   ... ... ...
  第n+1行：第n个学生的姓名 学号 成绩
  其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。
  输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。

---
*结构体数组*
动态分配 和 释放 
结构体里面套指针

*问题！！*
读取键盘输入放入结构体中函数 scanf_（）函数有问题，本机编译运行无错误，提交结果答案错误，修改为errblog中1004.c后提交正确。
修改内容： scanf() 放到主函数中，而不通过函数调用来写入。
*wrong!*
可以放到函数调用中，错误在于 判断结构体指针为空 应该在创建之后   
提示出错的部分反而变成错误所在！  
<a href="#catalogue"> back to catalogue </a>

##<p id ="1005">1005. 继续(3n+1)猜想 (25)</p>   
卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。
当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。
现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。

---
思路：
输入按递增排序
用卡拉兹猜想 计算第一个输入input[1] 所覆盖的数，放到数组output[n]中
比较后面的输入数据是否有在output数组中的，如果有，置零
将input[]按递减排序
重新卡拉兹计算output 覆盖的值置零
最后将非零input按照格式输出

---
思路有点繁杂，提交遇到问题，前三个正确，后面的段错误，经查，初始化output[300]，而递归中output[n]=n这样的赋值，会达到一个很大的值，而产生数组越界的问题，代码空间占用较大！
优化：递归中加判断n<300之后放到output中，保证output数组小于300。  
<a href="#catalogue"> back to catalogue </a>  

##<p id ="1006">1006. 换个格式输出整数 (15)</p>  
让我们用字母B来表示“百”、字母S表示“十”，用“12...n”来表示个位数字n（<10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。

输入格式：每个测试输入包含1个测试用例，给出正整数 n（<1000）。
输出格式：每个测试用例的输出占一行，用规定的格式输出 n。  
<a href="#catalogue"> back to catalogue </a>  

##<p id ="1007">1007. 素数对猜想 (20)</p>    
让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n>1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。

现给定任意正整数N (< 105)，请计算不超过N的满足猜想的素数对的个数。

输入格式：每个测试输入包含1个测试用例，给出正整数N。
输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。

---
判断n的素数 从2 到 n-1 循环 耗时过久，用sqrt(n)；for 循环中条件需要考虑清楚 < 和 <= 会对结果产生较大影响！
使用数组需要判断是否会造成越界！  
<a href="#catalogue"> back to catalogue </a>

##<p id ="1008">1008. 数组元素循环右移问题 (20)</p>    
一个数组A中存有N（N>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M>=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

输入格式：每个输入包含一个测试用例，第1行输入N ( 1<=N<=100)、M（M>=0）；第2行输入N个整数，之间用空格分隔。
输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 

---
需要考虑：只有一个数输入；右移数m > n 数字个数；
测试2 不通过：输入2 2 2 2 全部一样的时候有问题;修改，未通过；
输入5 10   1 2 3 4 5 出错；可能在恰好是整数倍情况下判断出错！解决通过!  
**考虑覆盖所有的可能性，注意循环或者条件判断中的等于情况**  
<a href="#catalogue"> back to catalogue </a>  

##<p id ="1009">1009. 说反话 (20)</p>    
给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。

输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。

输出格式：每个测试用例的输出占一行，输出倒序后的句子。

---
防御式编程，在调用函数判断输入的数组指针是否为NULL，如果多判断了函数内定义的指针，本机不报错，提交全部错误？
*不知道原因？！！*  
int change_str(char * input_str)
{ if (NULL == input_str || NULL == output_str) }  
<a href="#catalogue"> back to catalogue </a>

##<p id ="1010">1010. 一元多项式求导 (25)</p>    
设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）
输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。
输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。

---
  字符串输入可以有空格
  fgets(input_str, sizeof(input_str), stdin);  
<a href="#catalogue"> back to catalogue </a>  

##<p id ="1011">1011. A+B和C (15)</p>    
给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。
输入格式：
输入第1行给出正整数T(<=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。
输出格式：
对每组测试用例，在一行中输出“Case #X: true”如果A+B>C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。)

---
输入多个数字保存到数组，以空格分隔，回车结束输入；
while(1)
{
    scanf("%d", &data[pos++]);
    if( getchar() == '\n' )   break;
}
获取到 length = pos；length 即为数字个数，因为++ 表示操作之后再加1！
如果 getchar() 在 scanf 前面，则会从输入流中读取一个字节？而不传入 data 数组中！
个人感觉 goto 跳转在有特殊值情况的时候用起来比较方便。

动态分配 和 释放 多维数组遇到double free 问题，不知道现在的情况是否解决，vs单步调试的时候会报错，完整运行，和gcc环境都可以正常工作。
[n*m动态分配数组.c](https://github.com/yanzhirun/PAT-go/blob/master/pat/basic/Demo1/errblog/n*m%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E6%95%B0%E7%BB%84.c)  
<a href="#catalogue"> back to catalogue </a>  

##<p id ="1012">1012. 数字分类 (20)</p>    
给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：
A1 = 能被5整除的数字中所有偶数的和；
A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...；
A3 = 被5除后余2的数字的个数；
A4 = 被5除后余3的数字的平均数，精确到小数点后1位；
A5 = 被5除后余4的数字中最大数字。

输入格式：
每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。
输出格式：
对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。
若其中某一类数字不存在，则在相应位置输出“N”。

思路：输入N个数据，利用 errblog/n\*m动态分配数组.c 分配一位数组input[N] 对内部数据进行判断，
三目运算符 A？b：c  可以简化代码
整体代码还是很繁杂的，不过没有复杂的思考  
<a href="#catalogue"> back to catalogue </a>

##<p id ="1013">1013.数素数 (20)</p>    
令Pi表示第i个素数。现任给两个正整数M <= N <= 104，请输出PM到PN的所有素数。

输入格式：
输入在一行中给出M和N，其间以空格分隔。
输出格式：
输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。

---
找 n 的素数：从 2 到 sqrt(n) 包括(根号 n )
2 是第一个素数
do while 循环 while 为真 退出 为假继续 do 先执行了一遍 do
注意输出格式 前九个要加空格，第十个换行  
<a href="#catalogue"> back to catalogue </a>

##<p id ="1014">1014. 福尔摩斯的约会 (20)</p>  
大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母'D'，代表星期四；第2对相同的字符是'E'，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母's'出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。

输入格式：
输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。
输出格式：
在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。

---
switch () 只能是字符或者数字，字符要加单引号；要break; 要加default  
三目运算符 可以简化代码
if中的条件判断可以加括号 类似 ((()&&())||())最外层满足同样的 或 或者 且 关系；
*注意* 格式  看清题目要求 喜欢玩文字游戏 大小写 有符号 第几位 从0开始计算 末尾无空格之类。  
<a href="#catalogue"> back to catalogue </a>

##<p id ="1015">1015. 德才论 (25)</p>
宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”
现给出一批考生的德才分数，请根据司马光的理论给出录取排名。
输入格式：

输入第1行给出3个正整数，分别为：N（<=105），即考生总数；L（>=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。
随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。>
输出格式：
输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出

---
思路：两条分数线，两门课，分为四类，两门都达优秀线，两门都不达录取线，一门及格线一门达优秀线，两门都不达优秀线但达到录取线。
先按总分排序，并列的，先按德分，再按照准考证号，
三个数组放优秀 一半优秀 及格 的 不及格的不考虑。然后对这三组排序输出。

---
**关于动态分配和释放内存空间** 先分配外层 再 内层 释放的时候注意从内向外释放，所谓的向外释放 要把多维看成一维 实质上内存空间是按照1维存储的  
创建了 4\*4 的数组 前面是存放的数据 后面是地址 但是不同行的存放是不连续的？！~~（不知道对不对）！~~  
![结果图](https://github.com/yanzhirun/PAT-go/blob/master/pat/basic/Demo1/errblog/img/test_address%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BE.png)


复制二维数组 到另一个二维数组 [Code](https://github.com/yanzhirun/PAT-go/blob/master/pat/basic/Demo1/errblog/copy_nXn%E5%A4%8D%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.c)
>  memcpy(\*(coparr+i),\*(input+i), sizeof(int)\*3);  

定义二维数组arr[1][3] 1,3 表示的是大小，实际上用的是arr[0][]  
*传递参数*  
函数A() 函数B() A中定义二维数组arr[5][5] A调用B将数组传过去 void B((\*arr)[5]){} 即可
> int A()  
 {...  
 int arr[5][5];  
 B(arr);}  
> int B(int (\*arr)[4]){...}  

**二维数组和二级指针不是一个概念，传数组用如上方法。**  
****问题总结：* 提交的时候有两个测试用例超时，采用冒泡排序的时间太长，查资料换用 c 提供的函数 qsort()  

二维数组排序调用 qsort()  
  return a > b ? 1;-1;
  如果a > b 返回1 按照降序排列。  
  qsort() 最后一个参数cmp可任意取名 ，返回1 表示交换 0 相等。  
  cmp()的参数const * 内部强制转换，注意 一维二维，多维数组可以用结构体类型  

>qsort(sort_arr, ac_num, sizeof(*sort_arr), cmp);
>>int cmp(const void p, const void q)
{
    int **left = (int **)p;
    int **right = (int **)q;
    if ((*left)[3] ==(*right)[3])
    {
        if ((*left)[1] == (*right)[1])
        {
            return  ((*left)[0] > (*right)[0])? 1:-1;
        }
        else return ((*left)[1] > (*right)[1])? -1:1;
    }
    else return ((*left)[3] > (*right)[3])?-1:1;
}


  
![1015submit](https://github.com/yanzhirun/PAT-go/blob/master/pat/basic/Demo1/errblog/img/1015_submit.png)  
代码不够简洁，逻辑上是正确的，但是有很多是不必要的浪费  
如二维数组的第四列，由于开始时候思考的是放标志位，但是后来并没有起到太大作用，反而增大了使用空间。  
在输入的时候加人判断，剔除不合格的人选，后来创建四类人群数组的时候又判断了一次。

<a href="#catalogue"> back to catalogue </a>  

##<p id="1016">1016. 部分A+B (15)</p>  

正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。
现给定A、DA、B、DB，请编写程序计算PA + PB。
输入格式：
输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 < A, B < 1010。
输出格式：
在一行中输出PA + PB的值。  

---
*思路* 输入数据保存到char数组中，DA转化成int类型，strchr(string, 'c') 返回第一个指向 'c' 的指针， pow(10, n)计算10的n次方。  

问题：scanf()读取%c 会读空格 用%s 避开这个问题。加上getchar() 读取空格或者\n 。  

<a href="#catalogue"> back to catalogue </a>  

##<p id="1017">1017. A除以B (20)</p>  

本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。
输入格式：
输入在1行中依次给出A和B，中间以1空格分隔。
输出格式：
在1行中依次输出Q和R，中间以1空格分隔。
思路：
问题：第二个测试用例未通过，~~猜测是 被除数 小于 除数 如 3 / 5 应该返回0 3 添加一个判断 只有一位计算的使用普通的除法~~ 不通过
测试0 / 0  返回
>0 0
Floating point exception (core dumped)
  

再添加一个是0 的判断，直接输出0 0 OK 通过！  

<a href="#catalogue"> back to catalogue </a>  

##<p id="1018">1018. 锤子剪刀布 (20)</p>  
大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：  
![pat-basic-1018图](https://www.patest.cn/upload/7r_muvaqb4myb9.jpg)  
现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。  
输入格式：
输入第1行给出正整数N（<=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。
输出格式：
输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。  

思路：根据A的输入得到 A 和 B 的胜负和胜出手势，存入数组，根据数组判断输出结果。  
三目运算符 判断三位比较后的输出，代码少了，但是不容易看明白，这样写有利有弊。  
>tmp = ((p_win[i] >= p_win[tmp = (p_win[i+1] >= p_win[i+2] ? (i+1) : (i+2))]) ? i : tmp )- i;

问题：2号测试用例一直不通过，考虑全部是平局的情况，考虑输入 0 的情况
解决：想多了，不需要考虑全部平局时，统计每种手势次数，直接按照 B B 输出就可以  
题目描述不清楚！输出格式 是获胜次数最多的手势，不是要预测，所以不是统计所有手势。  

<a href="#catalogue"> back to catalogue </a>  

##<p id="1019">1019. 数字黑洞 (20)</p>  
给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。
例如，我们从6767开始，将得到
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
现给定任意4位正整数，请编写程序演示到达黑洞的过程。
输入格式：
输入给出一个(0, 10000)区间内的正整数N。
输出格式：
如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。

思路：输入保存到 int new_num 里，将每一位放到数组 arr_num[4] 里 排序，打印，递归调用 Kaprekar 算法 直到出现结果 6174

问题：注意输出格式 4位，不能直接输出数字， 0 开头的数 格式不匹配，输出 arr_num 数组。考虑特殊值 0 四位相同的 如2222，以及特殊点 6174 。

<a href="#catalogue"> back to catalogue </a>  


##<p id="1020">1020. 月饼 (25)</p>  

月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。
注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。
输入格式：  
每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。
输出格式：  
对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。

---
思路：保存到二维数组中，第三列存放单价，按照单价排序，先放单价最高的，放不满在放次高的，最后剩下的空间不能放完一种物品，放一部分。输出总价。  

问题：
提交出现段错误，考虑是否生成动态数组出错或者 free 出错。  
考虑判断过程出错
可以生成只有一行的数组，可以生成 1*1 的数组，释放也没有问题。  
输入数据 一行 报错 
>
Segmentation fault (core dumped)

一直没有发现问题所在，换用VS调试
>
while(p_commodity[i][0] <= i_need - total && i_kind > i)

这一行有问题，如果输入 3组数据， 都满足这个条件，i++之后，再进入这一行判断条件是否满足的时候 p_commodity[]就会越界，可以把while语句中的条件交换， i_kind>i 放在前面， 或者如下。
>
    while(p_commodity[i][0] <= i_need - total)
    {
        total += p_commodity[i][0];
        price += p_commodity[i][1];
        i++;
        if (i_kind <= i)
            break;
    }


按列输入的时候 scanf 语句需要注意 如下：  
>
    for (i = 0; i < i_kind; i++)
    {
        //    scanf ("%f", &p_commodity[i][0]);
        //    scanf ("%f", (p_commodity+i)[0]);
        scanf ("%f", *(p_commodity+i));
    }  

排序qsort() 需要注意cmp 部分。  

<a href="#catalogue"> back to catalogue </a>  

##<p id="1021">1021. 个位数统计 (15)</p>  

给定一个k位整数N = dk-1*10k-1 + ... + d1*101 + d0 (0<=di<=9, i=0,...,k-1, dk-1>0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。 d 
输入格式：  
每个输入包含1个测试用例，即一个不超过1000位的正整数N。  
输出格式：  
对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。  

思路：用字符数组存放输入数据，对每一位数字判断。  
注意 判断条件，输出格式。  

<a href="#catalogue"> back to catalogue </a>  

##<p id="1022">1022. D进制的A+B (20)</p>  
输入两个非负10进制整数A和B(<=230-1)，输出A+B的D (1 < D <= 10)进制数。
输入格式：
输入在一行中依次给出3个整数A、B和D。  
输出格式：
输出A+B的D进制数。  

思路：计算出 A + B 的和 ，转化成 i_D 进制的数用除 i_D 取余数，直到商为零，倒序输出余数即为所求。  



<a href="#catalogue"> back to catalogue </a>  


##<p id="1023">1023. 组个最小数 (20)</p>

给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。
现给定数字，请编写程序输出能够组成的最小的数。
输入格式：  
每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。
输出格式：  
在一行中输出能够组成的最小的数。

思路：输入保存到 num[10] 数组中第 i 位 是 i 的个数。当没有 0 的时候 按照顺序 输出， 当有 >= 1 个 0 的时候先输出一位，再输出所有的 0，然后按照顺序输出剩下的。  

注意 循环条件  

<a href="#catalogue"> back to catalogue </a>  
